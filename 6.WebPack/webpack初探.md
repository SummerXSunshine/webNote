## webpack是要干什么？
webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。它把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。
### 打包的场景
为什么打包？
- 逻辑多
- 文件多
- 项目复杂度
- loader实现翻译
- plugin对文件进行操作
- 即插即用
- 强大且灵活

### 模块化的优点（优点即目的）
- 作用域封装（模块化和闭包）
- 重用性（复用组件）
- 解除耦合（大工程）
### webpack打包过程
 1. 从入口文件开始，分析整个应用的依赖树
 2. 将每个依赖模块包装起来，放到一个数组中等待调用
 3. 实现模块加载的方法，并把它放到模块执行的环境中，确认模块间可以互相调用
 4. 把执行入口文件的罗技放在一个函数表达式中，并立即执行这个函数
## webpack的配置
### webpack是怎么打包的（原理）
- 打包之后是一个自执行函数
- 参数通过对象的形式传递的

```
在modules里面保存
key:文件的路径
value：函数eval
如果有多个相互依赖的文件打包成了一个文件
```

-   打包之后形成一个文件，通过__webpack_require__方法进行打包。
-   通过递归的方式不停的调用自己。

-   entry：
这部分是webpack的入口，Webpack执行构建的第一步将从入口开始搜寻及递归解析出所有入口依赖的模块。
-   output：
当webpack打包完所有的模块之后，输出的地方
- module： 定义rules用不同的loader加载不同类型的文件
- loaders：一下翻译器的配置
- plugins：一些插件的使用

## Webpack优化
**目的**
-   体积更小
-   速度更快

### 自带优化
- tree-shaking : 依赖关系解析--->不引入的代码不打包(mode:'production'有效 )
- scope-hoiting : 作用域提升

### 自定义优化
#### 提升速度
- 多线程打包->haapypack:    体积较小打包比较慢
- 时间插件->moment: 会引入很多不需要的语言包